package izettle

import (
	"izettle-daily-reports/util"
	"strconv"

	"github.com/shopspring/decimal"
)

type Purchases struct {
	Purchases []Purchase
}

type Purchase struct {
	PurchaseUUID       string            `json:"purchaseUUID"`
	PurchaseUUID1      string            `json:"purchaseUUID1"`
	Amount             util.Money        `json:"amount"`
	VatAmount          util.Money        `json:"vatAmount"`
	Country            string            `json:"country"`
	Currency           string            `json:"currency"`
	Timestamp          util.Date         `json:"timestamp"`
	GpsCoordinates     GpsCoordinate     `json:"gpsCoordinates"`
	PurchaseNumber     int               `json:"purchaseNumber"`
	UserDisplayName    string            `json:"userDisplayName"`
	UserID             int               `json:"userId"`
	OrganizationID     int               `json:"organizationId"`
	Products           []PurchaseProduct `json:"products"`
	Payments           []Payment         `json:"payments"`
	CashRegister       CashRegister      `json:"cashRegister"`
	ReceiptCopyAllowed bool              `json:"receiptCopyAllowed"`
	GroupedVatAmounts  GroupedVatAmounts `json:"groupedVatAmounts"`
	Refund             bool              `json:"refund"`
	Refunded           bool              `json:"refunded"`
}

type GpsCoordinate struct {
	Longitude      float64    `json:"longitude"`
	Latitude       float64    `json:"latitude"`
	AccuracyMeters util.Money `json:"accuracyMeters"`
}

type PurchaseProduct struct {
	Quantity         string     `json:"quantity"`
	VatPercentage    util.Money `json:"vatPercentage"`
	UnitPrice        util.Money `json:"unitPrice"`
	RowTaxableAmount int        `json:"rowTaxableAmount"`
	Name             string     `json:"name"`
	ProductUUID      string     `json:"productUuid"`
	VariantUUID      string     `json:"variantUuid"`
	Type             string     `json:"type"`
	ID               string     `json:"id"`
	Comment          string     `json:"comment"`
	AutoGenerated    bool       `json:"autoGenerated"`
	LibraryProduct   bool       `json:"libraryProduct"`
}

type PaymentAttribute struct {
	TransactionStatusInformation string `json:"transactionStatusInformation"`
	CardPaymentEntryMode         string `json:"cardPaymentEntryMode"`
	MaskedPan                    string `json:"maskedPan"`
	InstallmentAmount            int    `json:"installmentAmount"`
	ReferenceNumber              string `json:"referenceNumber"`
	NrOfInstallments             int    `json:"nrOfInstallments"`
	CardType                     string `json:"cardType"`
	TerminalVerificationResults  string `json:"terminalVerificationResults"`
	ApplicationIdentifier        string `json:"applicationIdentifier"`
	ApplicationName              string `json:"applicationName"`
}

type Payment struct {
	UUID           string           `json:"uuid"`
	Amount         util.Money       `json:"amount"`
	GratuityAmount int              `json:"gratuityAmount"`
	Type           string           `json:"type"`
	Attributes     PaymentAttribute `json:"attributes"`
}

type CashRegister struct {
	UUID        string `json:"uuid"`
	DisplayName string `json:"displayName"`
}

type GroupedVatAmounts struct {
	One21 int `json:"12.1"`
}

func (c *Client) Purchases(from util.Date, to util.Date) (*Purchases, error) {
	resource := "/purchases/v2?startDate=2019-01-01"
	resp := &struct {
		Purchases []Purchase
		LinkURLS  []string
	}{}
	err := c.GetRequest(purchaseURL, resource, resp)
	if err != nil {
		return nil, err
	}

	filteredPurchases := []Purchase{}
	for _, p := range resp.Purchases {
		if p.Timestamp.After(from) && p.Timestamp.Before(to) {
			purchase := p
			for i, prod := range purchase.Products {
				// We divide the price by 100 since a price of 100.00 is represented as
				// 10000.
				priceDividedBy100 := prod.UnitPrice.Div(decimal.NewFromInt(100))
				purchase.Products[i].UnitPrice = util.Money{priceDividedBy100}
			}
			filteredPurchases = append(filteredPurchases, purchase)
		}
	}

	return &Purchases{Purchases: filteredPurchases}, nil
}

type PurchaseSummary struct {
	Product *PurchaseProduct
	Count   int
	Amount  util.Money
}

type PurchaseSummaries struct {
	Purchase []PurchaseSummary
}

func (r PurchaseSummaries) Summary() PurchaseSummary {
	s := PurchaseSummary{}
	d := decimal.Zero
	for _, p := range r.Purchase {
		d = d.Add(p.Amount.Decimal)
		s.Count += p.Count
	}
	s.Amount = util.Money{d}
	return s
}

type GroupedPurchases struct {
	Date      util.Date
	User      int
	Username  string
	purchases Purchases
}

func (s GroupedPurchases) Summary() map[string]PurchaseSummaries {
	variants := make(map[string]PurchaseSummaries)
	for _, purchase := range s.purchases.Purchases {
		for i := range purchase.Products {
			product := purchase.Products[i]
			count, err := strconv.Atoi(product.Quantity)
			if err != nil {
				panic(err)
			}
			v := variants[product.VariantUUID]
			v.Purchase = append(v.Purchase, PurchaseSummary{
				Product: &product,
				Count:   count,
				Amount:  util.Money{product.UnitPrice.Mul(decimal.NewFromInt(int64(count)))},
			})
			variants[product.VariantUUID] = v
		}
	}
	return variants
}

func (p Purchases) GroupByDate() map[string]Purchases {
	dates := make(map[string]Purchases)
	for _, dp := range p.Purchases {
		date := dp.Timestamp.String()
		purchases := dates[date]
		purchases.Purchases = append(purchases.Purchases, dp)
		dates[date] = purchases
	}
	return dates
}

func (p Purchases) GroupByUser() map[int]Purchases {
	users := make(map[int]Purchases)
	for _, dp := range p.Purchases {
		user := dp.UserID
		purchases := users[user]
		purchases.Purchases = append(purchases.Purchases, dp)
		users[user] = purchases
	}
	return users
}

func (p Purchases) Group() []GroupedPurchases {
	grouped := []GroupedPurchases{}
	purchasesByDay := p.GroupByDate()
	for date, dp := range purchasesByDay {
		purchasesByUser := dp.GroupByUser()
		for _, up := range purchasesByUser {
			purchase := up.Purchases[0]
			gp := GroupedPurchases{
				Date:      util.DateFromStringOrPanic(date),
				User:      purchase.UserID,
				Username:  purchase.UserDisplayName,
				purchases: up,
			}
			grouped = append(grouped, gp)
		}
	}
	return grouped
}
